huawei知识点总结Vue.md

#### Vue3的setup
```js
接收两个参数：props，context（非props的attrs、slots、emit）
返回值：可以在模板template中被使用
```

#### Vue3的script setup语法
```js
1. 顶层的绑定会被暴露给模板
当使用 <script setup> 的时候，任何在 <script setup> 声明的顶层的绑定 (包括变量，函数声明，以及 import 引入的内容)
都能在模板中直接使用：
2. 导入的组件直接使用
3. defineProps() 和 defineEmits()
4. defineExpose()
使用 <script setup> 的组件是默认关闭的：
 通过模板 ref 或者 $parent 链获取到的组件的公开实例，不会暴露任何在 <script setup> 中声明的绑定；
◼ 通过 defineExpose 编译器宏来显式指定在 <script setup> 组件中要暴露出去的 property：

```
#### vue的自定义指令
```js
1. 运用场景：需要对DOM元素进行底层操作，这个时候就会用到自定义指令
2. 指令的生命周期：
◼ created：在绑定元素的 attribute 或事件监听器被应用之前调用；
◼ beforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用；
◼ mounted：在绑定元素的父组件被挂载后调用；
◼ beforeUpdate：在更新包含组件的 VNode 之前调用；
◼ updated：在包含组件的 VNode 及其子组件的 VNode 更新后调用；
◼ beforeUnmount：在卸载绑定元素的父组件之前调用；
◼ unmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次；
3. 参数和修饰符
button v-why:info.aaa.bbb="{name:'123z'}"
 info是参数的名称；
 aaa-bbb是修饰符的名称；
 后面是传入的具体的值；
```

#### Teleport组件
```js
组件传送到像要挂载的位置
比如移动到body元素上，或者我们有其他的div#app之外的元素上；
```
#### Vue插件
```js
1. 添加全局功能（vuex，pina，router都是全局功能，都是插件然后use）
2. 编写方式：
 对象类型：一个对象，但是必须包含一个 install 的函数，该函数会在安装插件时执行；
 函数类型：一个function，这个函数会在安装插件时自动执行；
3. 运用场景
 添加全局方法或者 property，通过把它们添加到 config.globalProperties 上实现；
 添加全局资源：指令/过滤器/过渡等；
 通过全局 mixin 来添加一些组件选项；
 一个库，提供自己的 API，同时提供上面提到的一个或多个功能；
````
#### 为什么要使用路由懒加载
```js
原因：
当打包构建应用时，JavaScript 包会变得非常大，影响页面加载：
 如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就会更加高效；
 也可以提高首屏的渲染效率；



```
#### 删除路由的方式
```js
◼ 删除路由有以下三种方式：
 方式一：添加一个name相同的路由；
 方式二：通过removeRoute方法，传入路由的名称；
 方式三：通过addRoute方法的返回值回调；
```
#### 匹配任意路由
```js
function addPathMatch() {
  if (!router.hasRoute("pathMatch")) {
    // /:pathMatch(.*)" 和 /:pathMatch(.*)*" 区别获取的$route.params.pathMatch的值不一样，一个是/a/n/，一个是数组['a','b']
    router.addRoute({
      path: "/:pathMatch(.*)",
      name: "pathMatch",
      redirect: "/error/404"
    });
  }
```
#### vue3的路由导航守卫不推荐使用next
```js
不再推荐使用next函数，这是因为开发中很容易调用多次next；
```
#### Vuex中action为什么需要携程返回promise形式？
```js
◼ Action 通常是异步的，那么如何知道 action 什么时候结束呢？
 我们可以通过让action返回Promise，在Promise的then中来处理完成后的操作；
```
#### pina与vuex的区别？
```js
◼ 和Vuex相比，Pinia有很多的优势：
 比如mutations 不再存在：
✓ 他们经常被认为是 非常 冗长；
✓ 他们最初带来了 devtools 集成，但这不再是问题；
 更友好的TypeScript支持，Vuex之前对TS的支持很不友好；
 不再有modules的嵌套结构：
✓ 你可以灵活使用每一个store，它们是通过扁平化的方式来相互使用的；
 也不再有命名空间的概念，不需要记住它们的复杂关系；

```
#### pina中改变state的方式
```js
1. store.count++
2. store.$patch({
  count: store.count + 1,
  age: 120,
  name: 'DIO',
})
store.$patch((state) => {
  state.items.push({ name: 'shoes', quantity: 1 })
  state.hasChanged = true
})
3.store.$state = { count: 24 }
```

project.md
```js
// defineComponent 函数和 h 函数来定义一个组件
import { ElCol } from "element-plus";
import { h, defineComponent } from "vue";
// 封装element-plus的el-col组件
export default defineComponent({
  name: "ReCol",
  props: {
    value: {
      type: Number,
      default: 24
    }
  },
  render() {
    const attrs = this.$attrs;
    const val = this.value;
    return h(
      // 参数1创建的元素类型
      ElCol,
      // 参数2这个元素的属性（props）和事件
      {
        xs: val,
        sm: val,
        md: val,
        lg: val,
        xl: val,
        ...attrs
      },
      // 默认插槽 (this.$slots.default()):
      { default: () => this.$slots.default() }
    );
  }
});

```




#### 大文件上传

pureAdmin.md
#### TS中??作用
```js
??`是一个空值合并运算符, 它的作用是，如果左侧表达式的值是 `null` 或者 `undefined`，则返回右侧表达式的值，否则返回左侧表达式的值
```

#### reactive中使用ccomputed的好处
```js
此结构有助于对各个部分进行模块化管理，使得每部分的状态都是根据其他状态动态计算的

const set: setType = reactive({
  sidebar: computed(() => {
    return useAppStoreHook().sidebar;
  }),

  device: computed(() => {
    return useAppStoreHook().device;
  }),

  fixedHeader: computed(() => {
    return pureSetting.fixedHeader;
  }),

  classes: computed(() => {
    return {
      hideSidebar: !set.sidebar.opened,
      openSidebar: set.sidebar.opened,
      withoutAnimation: set.sidebar.withoutAnimation,
      mobile: set.device === "mobile"
    };
  }),

  hideTabs: computed(() => {
    return $storage?.configure.hideTabs;
  })
});
```
#### 将指令封装成组件，这样做是为了什么？
```js
src\views\login\utils\motion.ts
import { h, defineComponent, withDirectives, resolveDirective } from "vue";

/** 封装@vueuse/motion动画库中的自定义指令v-motion */
export default defineComponent({
  name: "Motion",
  props: {
    delay: {
      type: Number,
      default: 50
    }
  },
  render() {
    const { delay } = this;
    // resolveDirective: 按名称手动解析已注册的指令。
    const motion = resolveDirective("motion");
    // withDirectives: 用于给 vnode 增加自定义指令。
    return withDirectives(
      h(
        "div",
        {},
        {
          default: () => [this.$slots.default()]
        }
      ),
      [
        [
          motion,
          {
            initial: { opacity: 0, y: 100 },
            enter: {
              opacity: 1,
              y: 0,
              transition: {
                delay
              }
            }
          }
        ]
      ]
    );
  }
});

// 使用
<Motion :delay="150">
   <el-form-item prop="password">
      <el-input
      v-model="ruleForm.password"
      clearable
      show-password
      :placeholder="t('login.purePassword')"
      :prefix-icon="useRenderIcon(Lock)"
      />
   </el-form-item>
</Motion>
```

#### useECharts中的setOptions里面可以用px，rem？官网未有
```js
    setOptions({
      container: ".bar-card",
      color: ["#41b6ff", "#e85f33"],
      tooltip: {
        trigger: "axis",
        axisPointer: {
          type: "none"
        }
      },
      grid: {
        top: "20px",
        left: "50px",
        right: 0
      },
      legend: {
        data: ["需求人数", "提问数量"],
        textStyle: {
          color: "#606266",
          fontSize: "0.875rem"
        },
        bottom: 0
      },
      xAxis: [
        {
          type: "category",
          data: ["周一", "周二", "周三", "周四", "周五", "周六", "周日"],
          axisLabel: {
            fontSize: "0.875rem"
          },
          axisPointer: {
            type: "shadow"
          }
        }
      ],
      yAxis: [
        {
          type: "value",
          axisLabel: {
            fontSize: "0.875rem"
          },
          splitLine: {
            show: false // 去网格线
          }
          // name: "单位: 个"
        }
      ],
      series: [
        {
          name: "需求人数",
          type: "bar",
          barWidth: 10,
          itemStyle: {
            color: "#41b6ff",
            borderRadius: [10, 10, 0, 0]
          },
          data: props.requireData
        },
        {
          name: "提问数量",
          type: "bar",
          barWidth: 10,
          itemStyle: {
            color: "#e86033ce",
            borderRadius: [10, 10, 0, 0]
          },
          data: props.questionData
        }
      ]
    });
```

#### 使用了rem，但是媒体查询没得html设置？


realProject.md
#### wepack对vue的分包
```js
◼ 默认的打包过程：
 默认情况下，在构建整个组件树的过程中，因为组件和组件之间是通过模块化直接依赖的，那么webpack在打包时就会将组
件模块打包到一起（比如一个app.js文件中）；
 这个时候随着项目的不断庞大，app.js文件的内容过大，会造成首屏的渲染速度变慢；

解决措施：
 所以，对于一些不需要立即使用的组件，我们可以单独对它们进行拆分，拆分成一些小的代码块chunk.js；
 这些chunk.js会在需要时从服务器加载下来，并且运行代码，显示对应的内容；

真实原理webpack怎么样进行分包？采用动态导入：import("./utils/math").then(({sum}) => {
   console.log(sum(20, 30))
})

vue中怎么分包？
采用动态组件defineAsyncComponent
 类型一：工厂函数，该工厂函数需要返回一个Promise对象；
 类型二：接受一个对象类型，对异步函数进行配置；

工厂函数是一种使用函数来创建并返回对象的模式。这种方式可以无需使用构造函数和new关键字来创建新对象。
工厂函数通常用来创建具有相似属性和方法的多个对象
```




